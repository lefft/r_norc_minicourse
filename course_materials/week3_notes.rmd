---
title: "R mini-course: week 3 notes"
author: "timothy leffel  &nbsp;&nbsp;&nbsp;&nbsp; xxxXX/2017"
output: html_document
css: css/notes.css
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE)
```

<hr style="height:2px; background-color: gray; color:gray;">

[FRONT MATTER]

<br><br>

[list of topics for this week from last week's notes]

- ...
- ...


<br>

### 0. [SECTION 0 HEADER]

<hr style="height:1px; background-color:lightgray; color:lightgray;">


We want to see if the wording of a question has an effect on how people (identified by an `id`) respond to it. The (categorical) grouping variable that determines what kind of wording they got is `form`, which takes the values 1 or 2 (which aren't categorical -- we'll recode them so that they are). 

We have three questions with alternative wordings, which we'd like to investigate (manipulated between-subjects, across the levels of `form`). The questions of interest are:

- `natcity` -- whether ...
    + blah
    + blah
- `natrace` -- whether ...
    + blah
    + blah
- `natfare` -- whether ...
    + blah
    + blah

Important question: should we be measuring variation across each individual outcome, or can we consider each question an "item" that appears in two conditions (`form==1`, `form==2`)?

Since the `form==2` questions for `nat*(y)` are all longer than their `form==1` counterpart, I'd say it makes sense to consider `form==2` an indication of *additional description*. Viewed this way, instead of having $n=2867$ observations of three different outcome variables, we now have $n=2867\times3=8601$ observations of a single outcome variable. But our outcome is spread across six columns...What'd be nice would be to have it instead as two columns: one indicating the question (i.e. `natcity` or `natrace` or `natfare`), and one indicating the response (i.e. `0`, `1`, `2`, `3`, `8`, or `9`). Since we already checked that `form` encodes wording type, we can safely just remove the `y` suffixes from the columns of interest. 

How do we arrive at our target format? 

There are many ways. Here's a natural one to implement: 

1. expand each row into six separate rows of `ncol(dat16) - 6 + 2` columns apiece, where the final six columns are deleted and replaced by two new columns `item` and `response` such that for each set of six rows `i:(i+5)` (all of whose values in columns `1:(ncol(dat16)-6)` are identical to the original value in the unexpanded row `i`): 
<!-- from which they were generated): -->
    + `dat16$item[i:(i+5)]` is the length-six character vector consisting of the names of the columns we're chopping off (i.e. `c("natcity","natcityy","natrace","natracey","natfare","natfarey")`); and 
    + `dat16$response[i:(i+5)]` contains the value of the chopped-off column with the name `dat16$item` specifies for that row.

2. delete all rows $i$ for which `dat16$value[i] %in% c(0,9)` (OR WE USE `NA` ALREADY?!), since: 
    + half of all the rows we generated in step 1. will have value `0`, since they didn't provide an answer to the corresponding `dat16$item` -- these aren't real data points; and
    + we can't use the "no answers," for present purposes they are dead to us.

Notice that now we've erased all the empty values, what we're left with is a dataset where `dat16$item` has one set of values for one level of `form`, and another set of distinct but corresponding values for the other level of `form`. But conceptually, the situation is that there's only three values of `dat16$item` -- not six -- and that `dat16$item` form tells us what kind of wording a particular subject got for the three items. This justifies identifying `*y` values in `dat16$item` with their corresponding `*` values. In other words, 

3. we delete all the trailing `y`'s from the `dat16$item` column. 


**note**: we shouldn't just delete all `y`'s, since `"natcityy"` has one that we don't want to chop off! 

**exercise**: how would you chop off all `"y"`'s from the column? 

**exercise**: what if anything could or would go wrong if we just chopped off all the `"y"`'s?

Now our data is (are?!) *fucking beautiful* and we're ready to start exploring it (although in the colloquial sense I'd say we've already explored it quite a bit!).

**note**: the steps we took above were motivated not just by intuition, but also by the concept of "tidy data," championed by Hadley Wickham et al. If you're interested, I'd **highly** recommend reading [this excellent paper](LINK), which is kind of a manifesto for a certain kind of "tidiness" through all phases of a data-related endeavor. 



We also want to see if demographic variables modulate the effect of wording on response. The demographic variables we have are: 

- `sex`
- `age`

These are all pretty self explanatory as far as what they represent goes, but other than `age` we don't really know the correspondence between the numeric codes and the real-world values they represent. To make the correspondence visible, we'll recode each of them to values we can look at and immediately understand.






```{r notestoself, include=FALSE}
# 1. read in data
#x 2. add "subj_" to `id` and make a factor/char
#x 4. do something with `raceenc1` and `raceenc2`
#x 5. melt over `nat*(y)`'s
#x 6. filter out all NA's from value col
#x 7. delete trailing `y`'s with regex
#x 8. collapse levels of income into "hi", "mid", "lo"


# 9. simple plots w base + qplot
# 10. formula interface for base plotting
# 
# 11. a buncha ggplots!
# 
# 12. how to apply this to your situation

# note: "%in%" <- function(x, table) match(x, table, nomatch = 0) > 0

```




**exercise**: use the commented code in the next chunk to make formatted tables, and compile an R-markdown document to print them nicely :)
```{r}
# to make nicer-looking tables:
# knitr::kable(t(as.table(colSums(is.na(dat)))))
# knitr::kable(table(dat$form), col.names=c("form","count"))
# knitr::kable(table(dat$sex), col.names=c("sex", "count"))
```


##### dk whar this goes 

Question: is it important *for our purposes* to distinguish between "refused" and "no answer" and "does not apply"? I'd say not, since none of them give us data and someone's proclivity for volunteering their race has nothing to do with what we want to measure or explore. Also, it's not even clear that proclivity is that these would indicate...



<br>

### 1. getting the data and defining the problem

<hr style="height:1px; background-color:lightgray; color:lightgray;">


```{r}
# [SECTION 1 CONTENT]
```




<br>

### 2. identifying necessary external information

<hr style="height:1px; background-color:lightgray; color:lightgray;">


```{r}
# [SECTION 2 CONTENT]
```


<br>

### 3. reading and cleaning and transforming the data

<hr style="height:1px; background-color:lightgray; color:lightgray;">


#### 3.1 read in data and inspect

```{r}
# read in the data and do some initial inspection
dat <- read.csv("datasets/gss_2016_test.csv") 

# check for na's (none, yay!)
colSums(is.na(dat))

str(dat)
head(dat, n=5)
```


#### 3.2 basic cleanup and recoding

```{r}
# now check + clean up + transform columns as necessary

# `id` is an identifier, not a number
dat$id <- paste0("resp", dat$id)

# `form` has just two levels
table(dat$form)

# so we can recode it with `ifelse()`
dat$form <- ifelse(dat$form==1, "standard", "alternate_y")

# `sex` has just two levels
table(dat$sex)

# so we can recode it with `ifelse()`
dat$sex <- ifelse(dat$sex==1, "male", "female")

# income has lots of different values
# ALSO BTW YAY FIRST PLOT! 
barplot(table(dat$INCOME16))

# so we'll have to recode it in a more mechanical fashion...

# one option:
# recode income to `hi` or `mid` or `lo`, according to external values
lo  <- 1:12; mid <- 13:21; hi  <- 22:26
dat$income_cat <- ifelse(
  dat$INCOME16 %in% lo, "lo", ifelse(
    dat$INCOME16 %in% mid, "mid", ifelse(
      dat$INCOME16 %in% hi, "hi", NA
    )
  )
); rm(lo); rm(mid); rm(hi)

# another option:
# read in external vals as a table, and just sub in values for numeric codes
income <- read.csv(
  "datasets/lookup_income.csv", header=FALSE, col.names=c("num","val"), 
  stringsAsFactors=FALSE
)
# make a vector with values equal to income$val, and names income$num
income_lkup        <- as.vector(income$val)
names(income_lkup) <- income$num

# recode the income column by matching vals w the lookup table names
dat$income_range <- income_lkup[match(dat$INCOME16, names(income_lkup))]

# remove the original income col
dat$INCOME16 <- NULL
```


#### 3.3 a slightly more complicated case

```{r}
# let's check out the race cols again
table(dat$racecen1, useNA="always")
table(dat$racecen2, useNA="always")

# kinda messy...let's just extract the census's notion of "ethnicity"
# (i.e. hispanic or non-hispanic)

# first read in our associative array of keys and values
race <- read.csv(
  "datasets/lookup_race.csv", header=FALSE, col.names=c("num","val"),
  stringsAsFactors=FALSE
)
race_lkup        <- as.vector(race$val)
names(race_lkup) <- race$num

dat$racecen1 <- ifelse(dat$racecen1 %in% c(0,98,99), NA, dat$racecen1)
dat$racecen2 <- ifelse(dat$racecen2 %in% c(0,98,99), NA, dat$racecen2)

dat$racecen1 <- race_lkup[match(dat$racecen1, names(race_lkup))]
dat$racecen2 <- race_lkup[match(dat$racecen2, names(race_lkup))]

dat$hisp <- ifelse(
  dat$racecen1=="Hispanic", "hispanic", "nonhispanic"
)
dat$hisp[dat$racecen2=="Hispanic"] <- "hispanic"

# now we can safely eliminate the `racecen1/2` columns
dat$racecen1 <- NULL; dat$racecen2 <- NULL
```


```{r}
# now we have everything except the outcome vars
# reorganize the df the way we want it
dem_cols  <- c("id", "year", "form", "sex", "age", "income_cat", "hisp")
item_cols <- names(dat)[startsWith(names(dat), "nat")]
dat <- dat[, c(dem_cols, item_cols)]
```


#### 3.2 data transformation with `reshape2::`

```{r}
# NATFARE/NATFAREY/NATCITY/NATCITYY/NATRACE/NATRACEY
#    9        "No answer"
#    8        "Don't know"
#    3        "Too much"
#    2        "About right"
#    1        "Too little"
#    0        "Not applicable"

library("reshape2")
dat <- melt(dat, id.vars=dem_cols)
dat$variable <- as.character(dat$variable)

knitr::kable(head(dat, n=10))
```

```{r}
# toss all the rows w/o real answers
dat <- dat[!dat$value %in% c(9, 8, 0), ]

# make a lookup table for the responses
val_lkup <- c(`1`="too little", `2`="about right", `3`="too much")

# recode responses as character
dat$value <- as.character(val_lkup[match(dat$value, names(val_lkup))])

# for now we'll just toss all y's to make life easier
dat$variable <- gsub("y", "", dat$variable)
```



<br>


### 4. summarizing and plotting the data

<hr style="height:1px; background-color:lightgray; color:lightgray;">


```{r}
# [SECTION 4 CONTENT]
```



<br>

### next week {#nextweek}

<hr style="height:1px; background-color:lightgray; color:lightgray;">


- topic 1
- topic 2
- ...

<br>

### appendix 1: analyzing the data with statistical models  {#appendix}

<hr style="height:1px; background-color:lightgray; color:lightgray;">


```{r}
# [APPENDIX CONTENT]
```

<br>

### appendix 2: the power of pipe-chains for data cleaning

<hr style="height:1px; background-color:lightgray; color:lightgray;">

if you don't think the word "power" quite applies here, try "concise", "clean", "pretty", "uniform", "simple", etc.

```{r}
library("dplyr")
dat16 <- read.csv("datasets/gss_2016_test.csv") %>% mutate(
  id = paste0("resp_", id),
  form = ifelse(form==1, "standard", "alternate_y"),
  sex = ifelse(sex==1, "male", "female")
)

```

<br>

### appendix 3: using `for`-loops to make animated gif plots!

<hr style="height:1px; background-color:lightgray; color:lightgray;">

Title is hopefully self-explanatory! Check out the super fun + cool `magick::` package (esp. [this nice vignette](https://cran.r-project.org/web/packages/magick/vignettes/intro.html)), which allows you to call image-magick functions directly from R. 

**exercise**: mark up the code below with comments explaining what's happening in each step or line of code, and why. (places where I'd suggest putting comments are marked with `# [comment here]` -- writing lots of comments is a good way to reinforce stuff in your memory)

```{r eval=TRUE}
library("ggplot2")
library("magick")

# [comment here]
df <- data.frame(
  time_worked = rep(seq(0, 1.4, .2), times=2),
  amount_done = c(seq(0, 4, .8)^2, 50, 100, seq(0, 9, 2)^2, 85, 90, 95),
  strategy    = rep(c("writing code", "point and click"), each=8)
)
# [comment here]
df <- arrange(df, time_worked)

# [comment here]
for (x in seq(from=2, to=nrow(df), by=2)){
  # [comment here]
  myplot <- 
    ggplot(df[1:x, ], aes(x=time_worked, y=amount_done, color=strategy)) + 
    # [comment here]
    geom_point() + 
    # [comment here]
    geom_line() +
    # [comment here]
    scale_x_continuous(limits=c(0, 1.5)) +
    scale_y_continuous(limits=c(0, 100)) +
    # [commment here]
    theme(legend.position="top", 
          axis.text=element_blank())
  
  # [comment here]
  fname_digit <- ifelse(x < 10, paste0("0", x), as.character(x))
  
  # [comment here]
  ggsave(
    filename=paste0("plots/myplot", fname_digit, ".png"), plot=myplot, 
    width=7, height=5, units="in"
  )
  
}

# [comment here]
gifcap <- c("yayyy, animated gif plot! \nwoop woop ~~ <(o_@)^")

# [comment here]
dir("plots/")[endsWith(dir("plots/"), ".png")] %>% 
  (function(x) paste0("plots/", x)) %>% 
  # [comment here]
  image_read() %>% 
  image_scale("x600") %>% 
  # [comment here]
  image_join() %>%
  image_animate(fps=2) %>% 
  # [comment here]
  image_annotate(gifcap, location="+100+100", color="green", size=30) %>% 
  # [comment here]
  image_write(path="output/animate_woop_woop.gif", quality=10)

```

Aaaand here's what we end up with:

![](output/animate_woop_woop.gif)


<hr><hr>
<br><br>



<link rel="stylesheet" type="text/css"
href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,400i,700">

<link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,400,500" rel="stylesheet">

  <style>
body {
  padding: 10px;
  font-size: 12pt;
  font-family: 'Open Sans', sans-serif;
}

h1 { 
  font-size: 20px;
  color: DarkGreen;
  font-weight: bold;
}

h2 { 
    font-size: 16px;
    color: green;
}

h3 { 
  font-size: 24px;
  color: green;
  font-weight: bold;
}

code {
  font-family: 'Roboto Mono', monospace;
  font-size: 14px;
}

pre {
  font-family: 'Roboto Mono', monospace;
  font-size: 14px;
}

p {
  margin-top: 30px;
  margin-bottom: 15px;
}

</style>



<!-- END OF DOCUMENT IS HERE -->

